# -*- coding: utf-8 -*-
"""Refactored_Forward_Pipeline.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1OBJEJx8rLWbcVBnb3DmgXdWmPpVFKwAb

## Imports
"""

import numpy as np
import argparse
from numpy.fft import fft2, ifft2, fftshift, ifftshift
from dataclasses import dataclass
from typing import Tuple, Literal, Optional
from pathlib import Path
import matplotlib.pyplot as plt
from typing import Tuple, Literal, Optional, Sequence, Dict, Mapping, Any
from IPython.display import display # Import display

"""## Parameters
Centralized run parameters. Update these to control sizes, seeds, and counts.
"""

# Core parameters (edit as needed)
SEED = 0
IMAGE_SIZE = 256
N_SYNTH = 8

"""## Parameter binding
Ensure variables derived from the parameters exist and are aligned with them.

## SyntheticData class
"""

class SyntheticData:
    """
    Create a synthetic <s_type> image with dimensions <height> X <width>
    """
    def __init__(self, s_type: str = "Checker Board", height: int = 256, width: int = 256) -> None:
        self.s_type = s_type
        self.height = height
        self.width = width

    def check_pattern(self, seed=0):
        rng = np.random.default_rng(seed)
        # Checkerboard
        y, x = np.indices((self.height, self.width))
        cb = ((x//16 + y//16) % 2).astype(float)

        # Slanted edge
        edge = (x - 0.7*y > self.width//3).astype(float)

        # Bright dots
        dots = np.zeros((self.height, self.width), float)
        for _ in range(30):
            i = rng.integers(0, self.height)
            j = rng.integers(0, self.width)
            dots[i, j] = 1.0

        img = 0.55*cb + 0.35*edge + 0.10*normalize01(rng.normal(size=(self.height, self.width)))
        img = np.clip(img + 0.6*dots, 0, 1)
        return img

    def ring_pattern(self, seed=0, freq=0.03):
        """
        Concentric ring pattern (radial sin wave).
        Useful to see radial frequency behavior and isotropy of blur.
        """
        rng = np.random.default_rng(seed)
        y, x = np.indices((self.height, self.width))
        cx, cy = self.width // 2, self.height // 2
        r = np.sqrt((x - cx)**2 + (y - cy)**2)

        rings = 0.5 + 0.5*np.sin(2*np.pi*freq*r)

        # Add small Gaussian noise for realism
        noise = normalize01(rng.normal(size=(self.height, self.width)))
        img = 0.9*rings + 0.1*noise
        return np.clip(img, 0, 1)

    def create_img(self, seed=0):
        if self.s_type == "Checker Board":
            return self.check_pattern(seed)
        elif self.s_type == "Rings":
            return self.ring_pattern(seed)
        else:
            raise ValueError(f"Unknown image type: {self.s_type}")

"""# Physics-Aware Forward Model: Coded-Exposure Motion Blur + Poisson–Gaussian Noise + MTF

This notebook stands up the forward imaging simulator for the project:

- Generate motion blur PSFs for **box** and **coded (flutter)** exposure  
- Convolve a synthetic scene to produce blurred images  
- Inject **Poisson–Gaussian** noise under a fixed photon budget  
- Compute and plot **PSF/OTF/MTF**  
- Compare **box vs coded** exposure under equal photon budgets

> Once these sanity checks are done, you can plug this into Wiener/RL baselines and later PnP/HQS with an MTF-aware denoising schedule.

## Synthetic test scene
"""


def default_output_dir() -> Path:
    try:
        base = Path(__file__).resolve().parent
    except NameError:
        base = Path.cwd()
    return base / "forward_model_outputs"


def configure_matplotlib_defaults() -> None:
    plt.rcParams["figure.figsize"] = (6, 4)
    plt.rcParams["figure.dpi"] = 120
    plt.rcParams["axes.grid"] = False


def load_input_image(
    image_path: Path,
    *,
    target_size: Optional[int] = None,
    normalize: bool = True,
) -> np.ndarray:
    """
    Load an image from disk, convert to grayscale, optionally resize, and return as float32 array.
    """
    try:
        from PIL import Image
    except ImportError as exc:  # pragma: no cover - defensive guard
        raise RuntimeError(
            "Pillow is required to load external images. Install it via `pip install pillow`."
        ) from exc

    img = Image.open(image_path).convert("F")
    if target_size is not None:
        img = img.resize((int(target_size), int(target_size)), Image.BICUBIC)

    arr = np.asarray(img, dtype=np.float32)
    if normalize:
        arr = np.clip(arr / 255.0, 0.0, 1.0)
    return arr


def axes_as_list(axs):
    if isinstance(axs, np.ndarray):
        return list(np.atleast_1d(axs).ravel())
    return [axs]


def finalize_figure(fig, outfile: Optional[Path], show_plots: bool):
    if outfile is not None:
        fig.savefig(outfile, bbox_inches="tight")
    if show_plots: # Add display here
      plt.show(fig)
    if not show_plots:
      plt.close(fig)


def is_prime(n: int) -> bool:
    if n <= 1:
        return False
    if n <= 3:
        return True
    if n % 2 == 0:
        return False
    limit = int(n ** 0.5) + 1
    for factor in range(3, limit, 2):
        if n % factor == 0:
            return False
    return True


def next_prime(n: int) -> int:
    candidate = max(2, int(n))
    if candidate <= 2:
        return 2
    if candidate % 2 == 0:
        candidate += 1
    while not is_prime(candidate):
        candidate += 2
    return candidate


def previous_prime(n: int) -> Optional[int]:
    candidate = int(n)
    if candidate < 2:
        return None
    if candidate == 2:
        return 2
    if candidate % 2 == 0:
        candidate -= 1
    while candidate >= 3:
        if is_prime(candidate):
            return candidate
        candidate -= 2
    return 2 if n >= 2 else None


def legendre_symbol(a: int, p: int) -> int:
    if p <= 2 or not is_prime(p):
        raise ValueError("Legendre symbol is defined for odd prime p >= 3.")
    a %= p
    if a == 0:
        return 0
    res = pow(a, (p - 1) // 2, p)
    if res == p - 1:
        return -1
    return res


def resolve_legendre_prime(length: int, prime: Optional[int]) -> int:
    if prime is not None:
        if not is_prime(prime):
            raise ValueError(f"Provided prime {prime} is not prime.")
        if prime < 3 or prime % 2 == 0:
            raise ValueError("Legendre sequence requires an odd prime >= 3.")
        return prime

    if length >= 3:
        candidate = previous_prime(length)
        if candidate is None or candidate < 3:
            candidate = next_prime(length)
    else:
        candidate = 3

    if candidate % 2 == 0:
        candidate = next_prime(candidate + 1)
    return candidate


def legendre_base_sequence(prime: int) -> np.ndarray:
    if not is_prime(prime) or prime < 3 or prime % 2 == 0:
        raise ValueError("Legendre sequence requires an odd prime length >= 3.")
    seq = np.zeros(prime, dtype=np.float64)
    seq[0] = 1.0
    for i in range(1, prime):
        seq[i] = 1.0 if legendre_symbol(i, prime) == 1 else 0.0
    return seq

def modified_legendre_sequence(
    length: int,
    prime: Optional[int] = None,
    rotation: int = 0,
    append_mode: Literal["auto", "append", "truncate", "repeat"] = "auto",
    flip: bool = False,
) -> np.ndarray:
    """
    Construct a (modified) Legendre sequence following Lee et al., ICCV 2013.

    The base sequence is generated for an odd prime `prime`, optionally rotated,
    and then fitted to the requested length via truncation/appending/repetition.
    """
    if length <= 0:
        raise ValueError("Sequence length must be positive.")

    base_prime = resolve_legendre_prime(length, prime)
    base = legendre_base_sequence(base_prime)
    rotation = int(rotation) % base_prime
    rotated = np.roll(base, -rotation)

    if append_mode == "auto":
        if length <= base_prime:
            mode = "truncate"
        elif length <= 2 * base_prime:
            mode = "append"
        else:
            mode = "repeat"
    else:
        mode = append_mode

    if mode == "truncate":
        if length > base_prime:
            raise ValueError("truncate mode requires length <= prime.")
        code = rotated[:length].copy()
    elif mode == "append":
        if length <= base_prime:
            code = rotated[:length].copy()
        else:
            if length > 2 * base_prime:
                raise ValueError("append mode supports lengths up to 2 * prime.")
            extra = length - base_prime
            extra = int(extra)
            code = np.concatenate([rotated, rotated[:extra]])
    elif mode == "repeat":
        reps, remainder = divmod(length, base_prime)
        segments = []
        if reps > 0:
            segments.append(np.tile(rotated, reps))
        if remainder:
            segments.append(rotated[:remainder])
        if segments:
            code = np.concatenate(segments)
        else:
            code = rotated[:length].copy()
    else:
        raise ValueError(f"Unknown append_mode '{mode}'.")

    if flip:
        code = 1.0 - code

    code = code.astype(np.float64, copy=False)
    if code.size != length:
        raise RuntimeError("Generated Legendre code has incorrect length.")
    if code.sum() == 0:
        code[0] = 1.0
    return code

def normalize01(x):
    x = x.astype(np.float64)
    m, M = x.min(), x.max()
    if M > m:
        return (x - m) / (M - m)
    return np.zeros_like(x)

def roll_centered(arr, shift):
    """Roll an array by 'shift' but keep center alignment semantics for kernels."""
    return np.roll(arr, shift - len(arr)//2)

def pad_to_shape(arr, shape):
    """Zero-pad arr to 'shape' (H, W) with arr centered."""
    H, W = shape
    h, w = arr.shape
    out = np.zeros((H, W), dtype=arr.dtype)
    y0 = (H - h)//2
    x0 = (W - w)//2
    out[y0:y0+h, x0:x0+w] = arr
    return out

"""## Exposure code patterns (box / random)"""


def make_exposure_code(T: int,
                       pattern: Literal["box","random","legendre"] = "box",
                       seed: Optional[int] = 0,
                       duty_cycle: float = 0.5,
                       legendre_params: Optional[Mapping[str, Any]] = None):
    """
    Create a binary exposure code of length T.
    - 'box': all ones (continuous open shutter)
    - 'random': Bernoulli(duty_cycle)
    - 'legendre': Modified Legendre sequence (ignores duty_cycle, accepts
      `legendre_params` such as `prime`, `rotation`, `append_mode`, `flip`)
    """
    if pattern == "box":
        return np.ones(T, dtype=float)
    elif pattern == "random":
        rng = np.random.default_rng(seed)
        code = (rng.random(T) < duty_cycle).astype(float)
        # Ensure non-empty
        if code.sum() == 0:
            code[rng.integers(0, T)] = 1.0
        return code
    elif pattern == "legendre":
        params = dict(legendre_params or {})
        if "prime" not in params:
            params["prime"] = resolve_legendre_prime(T, None)
        if "rotation" not in params and seed is not None:
            params["rotation"] = int(seed) % max(T, 1)
        code = modified_legendre_sequence(length=T, **params)
        if code.sum() == 0:
            code[0] = 1.0
        return code
    else:
        raise ValueError("Unknown pattern")

"""## Motion PSF from exposure code"""

def motion_psf_from_code(code: np.ndarray,
                         length_px: float) -> np.ndarray:
    """
    Build a 1D horizontal motion PSF using a binary exposure code.
    - code length T divides the exposure into T sub-intervals
    - length_px is the total blur length in pixels over the exposure
    We place impulses along the motion path wherever the shutter is '1',
    then normalize to unit sum.
    """
    T = len(code)
    positions = np.linspace(-length_px/2, length_px/2, T, endpoint=False) + length_px/(2*T)
    L = int(np.ceil(length_px))
    L = max(L, 1)
    psf = np.zeros(L, dtype=np.float64)
    for c, pos in zip(code, positions):
        if c <= 0:
            continue
        idx = int(np.floor((pos + length_px/2) / length_px * L))
        idx = np.clip(idx, 0, L-1)
        psf[idx] += 1.0
    s = psf.sum()
    if s > 0:
        psf /= s
    else:
        psf[L//2] = 1.0
    return psf

def kernel2d_from_psf1d(psf1d: np.ndarray) -> np.ndarray:
    """Lift 1D horizontal PSF to a 2D separable kernel (1 x L)."""
    return psf1d.reshape(1, -1)

"""## Convolution via FFT"""

def fft_convolve2d(img: np.ndarray, kernel: np.ndarray) -> np.ndarray:
    H, W = img.shape
    K = pad_to_shape(kernel, (H, W))
    IMG = fft2(img)
    KER = fft2(ifftshift(K))  # center kernel
    Y = IMG * KER
    y = np.real(ifft2(Y))
    return y

"""## OTF and MTF"""

def otf2d(kernel, shape):
    K = pad_to_shape(kernel, shape)
    return fftshift(fft2(ifftshift(K)))

def mtf_from_kernel(kernel, shape=(256, 256)):
    O = otf2d(kernel, shape)
    M = np.abs(O)
    M = M / (M.max() + 1e-12)
    return M

"""## Poisson–Gaussian noise under photon budgets"""

def add_poisson_gaussian(img: np.ndarray,
                         photon_budget: float = 2000.0,
                         read_noise_sigma: float = 0.01,
                         clip: bool = True,
                         rng_seed: int = 0):
    """
    img in [0,1]; scale by photon_budget => expected photoelectrons.
    Poisson shot noise is applied, then divided back to [0,1] scale.
    Additive Gaussian read noise is then added in [0,1] domain.
    """
    rng = np.random.default_rng(rng_seed)
    img01 = np.clip(img, 0, 1)
    lam = img01 * photon_budget
    y_counts = rng.poisson(lam=lam)
    y = y_counts / photon_budget
    y = y + rng.normal(0.0, read_noise_sigma, size=img.shape)
    if clip:
        y = np.clip(y, 0, 1)
    return y

"""## Illustrative spectral SNR comparison"""

def spectral_snr(img_clean: np.ndarray, img_noisy: np.ndarray, eps=1e-12):
    F_clean = fftshift(fft2(img_clean))
    F_noisy = fftshift(fft2(img_noisy))
    P_signal = np.abs(F_clean)**2
    P_noise = np.abs(F_noisy - F_clean)**2
    ssnr = (P_signal + eps) / (P_noise + eps)
    return np.log10(ssnr + 1.0)

from __future__ import annotations
from pathlib import Path
from typing import Any, Dict, Mapping, Optional, Sequence, Tuple, Callable, List
import numpy as np
import matplotlib.pyplot as plt

# Assumed available in your codebase:
# default_output_dir, finalize_figure, axes_as_list
# resolve_legendre_prime, make_exposure_code
# motion_psf_from_code, kernel2d_from_psf1d, fft_convolve2d
# add_poisson_gaussian, mtf_from_kernel, spectral_snr

class ForwardModelRunner:
    """Run and visualize the forward imaging model for one or more exposure patterns."""

    def __init__(
        self,
        img: np.ndarray,
        patterns: Sequence[str] = ("box", "random", "legendre"),
        *,
        selected_pattern: Optional[str] = None,
        T: int = 31,
        blur_length_px: float = 15.0,
        duty_cycle: float = 0.5,
        random_seed: int = 0,
        photon_budget: float = 1000.0,
        read_noise_sigma: float = 0.01,
        show_plots: bool = True,
        # Saving controls (default: do NOT save anything)
        save_arrays: bool = False,
        save_pngs: bool = False,
        save_figures: bool = False,
        output_dir: Optional[Path] = None,
        legendre_params: Optional[Mapping[str, Any]] = None,
        # New: control console output
        verbose: bool = False,
        logger: Optional[Callable[[str], None]] = None,
    ) -> None:
        self.scene = img

        # Only the selected pattern should be used/shown
        if selected_pattern is not None:
            self.patterns = (selected_pattern,)
        else:
            self.patterns = tuple(patterns)

        self.T = int(T)
        self.blur_length_px = float(blur_length_px)
        self.duty_cycle = float(duty_cycle)
        self.random_seed = int(random_seed)
        self.photon_budget = float(photon_budget)
        self.read_noise_sigma = float(read_noise_sigma)
        self.show_plots = bool(show_plots)

        self.legendre_params = dict(legendre_params or {})

        # Saving flags
        self.save_arrays = bool(save_arrays)
        self.save_pngs = bool(save_pngs)
        self.save_figures = bool(save_figures)

        # Output dirs (created lazily)
        self._output_dir_req = output_dir
        self.output_dir: Optional[Path] = None
        self.arrays_dir: Optional[Path] = None
        self.figures_dir: Optional[Path] = None

        self.results: Dict[str, Dict[str, Any]] = {}

        # Verbosity / logging
        self.verbose = bool(verbose)
        self._logger = logger or (lambda s: print(s))
        self.warnings: List[str] = []

    # ---------- Utility: conditional logging ----------

    def _log(self, msg: str) -> None:
        if self.verbose:
            self._logger(msg)

    def _warn(self, msg: str) -> None:
        # Never print automatically; store and (optionally) emit under verbose
        self.warnings.append(msg)
        self._log(f"Warning: {msg}")

    # ---------- Public API ----------

    def run(self) -> Dict[str, Any]:
        """Execute the full pipeline: visualize scene, simulate, visualize, and optionally persist."""
        # Prepare dirs only if we will save something
        if self.save_arrays or self.save_pngs or self.save_figures:
            self.output_dir, self.arrays_dir, self.figures_dir = self._prepare_output_dirs(self._output_dir_req)

        # Scene plot (only save if requested; otherwise just show)
        self._plot_scene()

        # Simulate only the requested patterns (often a single one)
        for idx, pattern in enumerate(self.patterns):
            self.results[pattern] = self._process_pattern(pattern, idx)

        # Visualizations (these will only save if save_figures=True)
        self._plot_psf_1d()
        self._plot_blurred_images()
        self._plot_mtf_images()
        self._plot_mtf_slice()
        self._plot_noisy_images()
        self._plot_ssnr_images()

        # Persistence (only if explicitly requested)
        if self.save_arrays:
            self._save_arrays()
        if self.save_pngs:
            self._save_pngs()

        if self.save_arrays or self.save_pngs or self.save_figures:
            self._log(f"Saved to: {self.output_dir}")

        return {
            "scene": self.scene,
            "patterns": self.results,
            "output_dir": self.output_dir,
            "arrays_dir": self.arrays_dir,
            "figures_dir": self.figures_dir,
            "warnings": list(self.warnings),
        }

    # ---------- Directory / I/O ----------

    def _prepare_output_dirs(self, output_dir: Optional[Path]) -> Tuple[Path, Path, Path]:
        if output_dir is None:
            output_dir = default_output_dir()
        output_dir = Path(output_dir)
        arrays_dir = output_dir / "arrays"
        figures_dir = output_dir / "figures"
        output_dir.mkdir(parents=True, exist_ok=True)
        arrays_dir.mkdir(parents=True, exist_ok=True)
        figures_dir.mkdir(parents=True, exist_ok=True)
        return output_dir, arrays_dir, figures_dir

    def _save_arrays(self) -> None:
        assert self.arrays_dir is not None
        np.save(self.arrays_dir / "scene.npy", self.scene)
        for pattern, data in self.results.items():
            safe = pattern.lower().replace(" ", "_")
            np.save(self.arrays_dir / f"code_{safe}.npy", data["code"])
            np.save(self.arrays_dir / f"psf_{safe}.npy", data["psf"])
            np.save(self.arrays_dir / f"k_{safe}.npy", data["kernel"])
            np.save(self.arrays_dir / f"y_{safe}.npy", data["blurred"])
            np.save(self.arrays_dir / f"y_{safe}_noisy.npy", data["noisy"])
            np.save(self.arrays_dir / f"mtf_{safe}.npy", data["mtf"])
            np.save(self.arrays_dir / f"ssnr_{safe}.npy", data["ssnr"])

    def _save_pngs(self) -> None:
        assert self.output_dir is not None
        try:
            import imageio.v2 as imageio  # type: ignore
        except ImportError:
            self._warn("imageio is not available; skipping PNG exports.")
            return

        scene_png = np.clip(self.scene * 255, 0, 255).astype(np.uint8)
        imageio.imwrite(self.output_dir / "scene.png", scene_png)
        for pattern, data in self.results.items():
            safe = pattern.lower().replace(" ", "_")
            png = np.clip(data["noisy"] * 255, 0, 255).astype(np.uint8)
            imageio.imwrite(self.output_dir / f"y_{safe}_noisy.png", png)

    # ---------- Core per-pattern pipeline ----------

    def _process_pattern(self, pattern: str, idx: int) -> Dict[str, Any]:
        label = pattern.replace("_", " ").title()
        pattern_seed = self.random_seed + idx

        # Legendre handling: preserve canonical rotation via base seed
        seed_arg: Optional[int] = pattern_seed
        current_legendre_params: Optional[Dict[str, Any]] = None
        if pattern == "legendre":
            pattern_seed = self.random_seed
            current_legendre_params = dict(self.legendre_params)
            if "prime" not in current_legendre_params:
                current_legendre_params["prime"] = resolve_legendre_prime(self.T, None)
            if "rotation" not in current_legendre_params:
                prime_used = int(current_legendre_params["prime"])
                current_legendre_params["rotation"] = int(pattern_seed) % prime_used
            seed_arg = None  # encoded via rotation

        code = self._make_code(pattern, seed_arg, current_legendre_params)
        psf = motion_psf_from_code(code, length_px=self.blur_length_px)
        kernel = kernel2d_from_psf1d(psf)
        blurred = fft_convolve2d(self.scene, kernel)
        noisy = add_poisson_gaussian(
            blurred,
            photon_budget=self.photon_budget,
            read_noise_sigma=self.read_noise_sigma,
            rng_seed=self.random_seed + idx,
        )
        mtf = mtf_from_kernel(kernel, self.scene.shape)
        ssnr = spectral_snr(blurred, noisy)

        metadata: Dict[str, Any] = {"pattern": pattern}
        if current_legendre_params is not None:
            metadata.update(current_legendre_params)

        # Only print if verbose
        self._print_pattern_summary(label, code, current_legendre_params)

        return {
            "label": label,
            "code": code,
            "psf": psf,
            "kernel": kernel,
            "blurred": blurred,
            "noisy": noisy,
            "mtf": mtf,
            "ssnr": ssnr,
            "duty_cycle": float(code.mean()),
            "metadata": metadata,
        }

    def _make_code(
        self,
        pattern: str,
        seed_arg: Optional[int],
        legendre_params: Optional[Mapping[str, Any]],
    ) -> np.ndarray:
        return make_exposure_code(
            self.T,
            pattern=pattern,  # type: ignore[arg-type]
            seed=seed_arg,
            duty_cycle=self.duty_cycle,
            legendre_params=legendre_params,
        )

    def _print_pattern_summary(
        self, label: str, code: np.ndarray, legendre_params: Optional[Mapping[str, Any]]
    ) -> None:
        if not self.verbose:
            return
        self._log(f"{label} code (T={self.T}): {code.astype(int)}")
        self._log(f"  Duty cycle: {code.mean():.3f}")
        if legendre_params is not None:
            prime_info = int(legendre_params["prime"])
            rotation_info = int(legendre_params.get("rotation", 0))
            mode_info = legendre_params.get("append_mode", "auto")
            flip_info = bool(legendre_params.get("flip", False))
            self._log(
                f"  Prime: {prime_info}, rotation: {rotation_info}, "
                f"append_mode: {mode_info}, flip: {flip_info}"
            )

    # ---------- Plotting (save only if save_figures=True) ----------

    def _plot_scene(self) -> None:
        fig, ax = plt.subplots()
        ax.imshow(self.scene, cmap="gray")
        ax.set_title("Synthetic Scene")
        ax.axis("off")
        if self.save_figures and self.figures_dir is not None:
            finalize_figure(fig, self.figures_dir / "scene.png", self.show_plots)
        else:
            if self.show_plots:
                plt.show()
            plt.close(fig)

    def _plot_psf_1d(self) -> None:
        fig, ax = plt.subplots()
        for pattern in self.patterns:
            data = self.results[pattern]
            ax.plot(data["psf"], label=data["label"])
        ax.set_title("1D PSF (horizontal)")
        ax.legend()
        if self.save_figures and self.figures_dir is not None:
            finalize_figure(fig, self.figures_dir / "psf_1d.png", self.show_plots)
        else:
            if self.show_plots:
                plt.show()
            plt.close(fig)

    def _plot_blurred_images(self) -> None:
        fig, axs = plt.subplots(1, len(self.patterns) + 1, figsize=(4 * (len(self.patterns) + 1), 3))
        axes = axes_as_list(axs)
        axes[0].imshow(self.scene, cmap="gray")
        axes[0].set_title("Original")
        axes[0].axis("off")
        for ax, pattern in zip(axes[1:], self.patterns):
            data = self.results[pattern]
            ax.imshow(data["blurred"], cmap="gray")
            ax.set_title(f"Blur ({data['label']})")
            ax.axis("off")
        if self.save_figures and self.figures_dir is not None:
            finalize_figure(fig, self.figures_dir / "blurred.png", self.show_plots)
        else:
            if self.show_plots:
                plt.show()
            plt.close(fig)

    def _plot_mtf_images(self) -> None:
        gamma = 0.5
        ncols = max(len(self.patterns), 1)
        fig, axs = plt.subplots(1, ncols, figsize=(4 * ncols, 3))
        axes = axes_as_list(axs)
        for ax, pattern in zip(axes, self.patterns):
            data = self.results[pattern]
            ax.imshow(data["mtf"] ** gamma, cmap="gray")
            ax.set_title(f"MTF ({data['label']})")
            ax.axis("off")
        if self.save_figures and self.figures_dir is not None:
            finalize_figure(fig, self.figures_dir / "mtf.png", self.show_plots)
        else:
            if self.show_plots:
                plt.show()
            plt.close(fig)

    def _plot_mtf_slice(self) -> None:
        fig, ax = plt.subplots()
        mid = self.scene.shape[0] // 2
        for pattern in self.patterns:
            data = self.results[pattern]
            ax.plot(data["mtf"][mid], label=data["label"])
        ax.set_title("MTF horizontal slice (normalized)")
        ax.set_xlabel("Spatial frequency index")
        ax.set_ylabel("Magnitude")
        ax.legend()
        if self.save_figures and self.figures_dir is not None:
            finalize_figure(fig, self.figures_dir / "mtf_slice.png", self.show_plots)
        else:
            if self.show_plots:
                plt.show()
            plt.close(fig)

    def _plot_noisy_images(self) -> None:
        fig, axs = plt.subplots(1, len(self.patterns) + 1, figsize=(4 * (len(self.patterns) + 1), 3))
        axes = axes_as_list(axs)
        axes[0].imshow(self.scene, cmap="gray")
        axes[0].set_title("Original")
        axes[0].axis("off")
        for ax, pattern in zip(axes[1:], self.patterns):
            data = self.results[pattern]
            ax.imshow(data["noisy"], cmap="gray")
            ax.set_title(f"{data['label']} + noise")
            ax.axis("off")
        if self.save_figures and self.figures_dir is not None:
            finalize_figure(fig, self.figures_dir / "noisy.png", self.show_plots)
        else:
            if self.show_plots:
                plt.show()
            plt.close(fig)

    def _plot_ssnr_images(self) -> None:
        ncols = max(len(self.patterns), 1)
        fig, axs = plt.subplots(1, ncols, figsize=(4 * ncols, 3))
        axes = axes_as_list(axs)
        for ax, pattern in zip(axes, self.patterns):
            data = self.results[pattern]
            ax.imshow(data["ssnr"], cmap="gray")
            ax.set_title(f"Spectral SNR ({data['label']})")
            ax.axis("off")
        if self.save_figures and self.figures_dir is not None:
            finalize_figure(fig, self.figures_dir / "spectral_snr.png", self.show_plots)
        else:
            if self.show_plots:
                plt.show()
            plt.close(fig)


# Back-compatible convenience function (now with selection & save flags)
def run_forward_model(
    img,
    patterns: Sequence[str] = ("box", "random", "legendre"),
    T: int = 31,
    blur_length_px: float = 15.0,
    duty_cycle: float = 0.5,
    random_seed: int = 0,
    photon_budget: float = 1000.0,
    read_noise_sigma: float = 0.01,
    show_plots: bool = True,
    output_dir: Optional[Path] = None,
    legendre_params: Optional[Mapping[str, Any]] = None,
    *,
    selected_pattern: Optional[str] = None,
    save_arrays: bool = False,
    save_pngs: bool = False,
    save_figures: bool = False,
    verbose: bool = False,
    logger: Optional[Callable[[str], None]] = None,
) -> Dict[str, Any]:
    configure_matplotlib_defaults()
    img_array = np.asarray(img, dtype=np.float32)

    runner = ForwardModelRunner(
        img=img_array,
        patterns=patterns,
        selected_pattern=selected_pattern,
        T=T,
        blur_length_px=blur_length_px,
        duty_cycle=duty_cycle,
        random_seed=random_seed,
        photon_budget=photon_budget,
        read_noise_sigma=read_noise_sigma,
        show_plots=show_plots,
        save_arrays=save_arrays,
        save_pngs=save_pngs,
        save_figures=save_figures,
        output_dir=output_dir,
        legendre_params=legendre_params,
        verbose=verbose,
        logger=logger,
    )
    return runner.run()

if __name__ == "__main__":
    checkerboard_scene = SyntheticData("Checker Board").create_img(SEED)
    run_forward_model(
        checkerboard_scene,
        patterns=["box", "random", "legendre"],
        show_plots=True,
        verbose=False,
    )

    ring_scene = SyntheticData("Rings").create_img(SEED)
    run_forward_model(
        ring_scene,
        patterns=["box", "random", "legendre"],
        show_plots=True,
        verbose=False,
    )

    # Future work items from the original research notebook
    # - Implement Wiener and Richardson-Lucy deconvolution baselines using k_box and k_coded.
    # - Integrate PnP/HQS with a fixed denoiser and constant sigma schedule.
    # - Develop an MTF-aware schedule that adapts denoising strength across frequencies.
    # - Compare fixed, monotone, and MTF-aware schedules while varying code patterns under equal photon budgets.

